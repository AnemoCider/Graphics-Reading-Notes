# Nanite: virtulized geometry

参考Epic的分享[^1]。

## Intro

Virtual texturing让美术可以用巨大的texture，不用关心内存开销。与之类似的是，virtualized geometry理论上可以让美术随意使用电影级的资产，不用考虑poly count, draw call次数，或者内存，并且不会有质量损失。

然而，texture更多是内存方面的限制，但是geometry会涉及到管线的更多部分，非常影响渲染开销；另外，geometry不像texture一样可以比较轻易地filter。

### Options

#### Voxels

用Voxel作为场景的高精度表示并不算很新的想法。早在2008年卡神[^2]就提出过用sparse voxel octree(SVO)来加速ray tracing的想法，其一是ray trace三角形的开销不低，另一方面是他认为未来需要texel级别精度的geometry，而光栅化管线并不擅长渲染比像素小的三角形（了解过nanite的朋友大概会觉得这很熟悉...但这已经是16年前的观点了）(疑问：这是否也属于software raster要解决的问题之一？)。另外，目前常用的表达高精度模型的方式是粗糙的triangle mesh + 高精度的color和displacement map，然后用virtual texturing来支持；而使用voxel可以直接把per-sample的高精度数据存下来，数据结构层面要简洁很多。[^3]

Unreal尝试使用的是sdf voxel。然而，即使是在优化之后，voxel的表示仍然需要6倍的数据量，并且最终mesh转voxel的uniform resampling也会带来相当的质量损失。另外，voxel的表达与传统的美术资产，比如uv mapping的兼容并不好，所以这套流程需要改的东西太多了。除此之外，sdf也有很多传统问题。总体评价是未来可期。

#### Subdivision surfaces

尽管Subdivision上限非常高，但是并不能做到简化模型；而现实是游戏里一定需要大量使用LOD这样减少顶点数的手段。所以这不能作为普遍方案来用。

#### Displacement Maps

Displacement map可以有效地减少顶点数。然而，displacement有固有的几何表达能力的缺陷，比如不能把一个球displace成环面，因此难以表达特定模型。另外，normal/displacement map也需要转Voxel那样的uniform resampling，对于hard surface很容易造成质量损失。所以这也很难作为普遍方案。

#### Points

Point-based的问题是缺少connectivity信息（没有index buffer的triangle mesh），所以得去填点之间的gap。现代ml denoising可以解决一部分这个问题，但不能解决全部。

#### Triangles

上述的做法在特定情境下或许各有优势，但unreal engine必须要一个通用的方案。所以最终我们又回到了triangle mesh.

## GPU Driven Pipeline

### Building Blocks

Nanite的开发基础是Unreal的retained mode渲染，也就是会有一个GPU端的scene。另外，mesh相关的数据（vertex和index buffer）都放在一个resource里，所以就可以只用一发dispatch做culling，或者一次DrawIndirect做depth pass.

### Background: GPU Driven

基于刺客信条的这篇经典的分享[^4]。

#### Programmable Vertex Pulling Rendering Pipeline

刺客信条的Mesh cluster部分引用了这篇[^5]。

由于draw call有overhead（主要是切换state和resource），渲染的瓶颈有时是在CPU上。早期的解法包括：

- OpenGL 3的instancing。然而，instancing限制了模型的复杂度。
- Batching。对静态物体很好用，但是batching会导致剔除的粒度变大、效果变差；同时，batching会有内存开销，比如Unity的static batching会复制每个gameObject的mesh，即使它们用的是同一个model。

一种比较灵活的解法是合并resources， 例如VAO直接打包起来用base vertex去offset, texture用texture array。这样避免了资源切换的大部分开销，但是：

- draw call submission本身的开销仍无法避免，例如driver的状态检查。
- Culling，CPU渲染occluder会有不小的开销，而从GPU回读depth又会有延迟。

因此，更好的解法应当是让GPU自己去做剔除并且提交draw call。

#### Assassin's Creed: Mesh Cluster



### Culling


[^1]: [2021 Nanite: A Deep Dive](https://advances.realtimerendering.com/s2021/Karis_Nanite_SIGGRAPH_Advances_2021_final.pdf)

[^2]: [2008 John Carmack on idTech6, Ray Tracing, Consoles, Physics and More](https://pcper.com/2008/03/john-carmack-on-id-tech-6-ray-tracing-consoles-physics-and-more/)

[^3]: [2010 Efficient Sparse Voxel Octrees](https://research.nvidia.com/sites/default/files/pubs/2010-02_Efficient-Sparse-Voxel/laine2010i3d_paper.pdf)

[^4]: [2015 GPU-Driven Rendering Pipelines](https://advances.realtimerendering.com/s2015/aaltonenhaar_siggraph2015_combined_final_footer_220dpi.pdf)

[^5]: [2013 Introducing the Programmable Vertex Pulling Rendering Pipeline, GPU Pro 4]

